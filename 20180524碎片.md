# 20180524碎片

## 推荐系统

按照维基百科的定义：它是一种信息过滤系统，手段是通过预测用户(User)对物品(Item)的评分和偏好。这个定义不是很好理解，也不恰当。它用“怎么做”来定义了“是什么”，这相当于变相规定了推荐系统的实现路径。

判断是否需要推荐系统的指标

![](https://mmbiz.qpic.cn/mmbiz_png/f7S9WVpDh3iavALIicCl0srAZll8ib7zmLSnxcLbiccx8gRSUr47FcxTe1BczR2icvQhdx9bSgZX45Z1bvibDj7cSnag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

分子是增加的连接数，分母是增加的活跃用户数和增加的有效物品数。这个简单的指标我解释一下：


如果增加的连接数主要靠增加的活跃用户数和增加的物品数贡献，则该值会较小，不适合加入推荐系统。

如果增加的连接数和新增活跃用户和物品关系不大，那说明连接数已经有自发生长的趋势了，适合加入推荐系统加速这一过程。

https://mp.weixin.qq.com/s/S0zR5JgAqZSPTmNw0PkrDg

## 时间序列预测之--ARIMA模型

ARIMA模型的全称叫做**自回归移动平均模型**，全称是(ARIMA, Autoregressive Integrated Moving Average Model)。也记作ARIMA(p,d,q)，是统计模型(statistic model)中最常见的一种用来进行时间序列预测的模型。

ARIMA的预测模型可以表示为：
Y的预测值 = 常量c and/or 一个或多个最近时间的Y的加权和 and/or 一个或多个最近时间的预测误差


## 时间序列

时间序列也称动态序列，是指将某种现象的指标数值按照时间顺序排列而成的数值序列。大量的社会经济统计指标都是依据年、季度、月、日，甚至实时（秒）统计的，因此，时间序列是某个统计指标（变量）长期变动的数值表现。

时间序列可以反映某个现象的发展变化状态。通过对时间序列的分析，可以反映现象发展变化的趋势和规律，再通过对影响时间序列的各种因素进行测定，可以进一步解释现象变化的内在原因，为预测和决策提供可靠的数据支持

因为时间序列是某个指标数值长期变化的数值表现，所以时间序列数值变化背后必然蕴含着数值变换的规律性，这些规律性就是时间序列分析的切入点。一般情况下，时间序列的数值变化规律有以下四种：长期变动趋势、季节变动规律、周期变动规律和不规则变动。不同的数值变化规律是由不同影响因素决定的。这些影响因素有长期起作用的因素，也有短期因素；有可以预知和控制的因素，也有未知和不可控制的因素；这些因素相互作用和影响，从而使时间序列的变化趋势呈现不同的特点。根据影响因素对时间序列数值变化趋势的不同影响情况，可以分为四种影响因素：长期趋势影响因素、季节变动影响因素、循环变动影响因素和不规则变动影响因素。

https://mp.weixin.qq.com/s?__biz=MjM5MTI5MDgxOA==&mid=2650098598&idx=1&sn=764836a01bd90b722fb555bb37306ae5&chksm=beb62f0b89c1a61dea9c22b096e0d1533335af649f74ea13987ffe6029fb3680d7e06664f914&scene=21#wechat_redirect

## Disruptor高性能队列

LMAX Disruptor是一个高性能的线程间消息库。它源于LMAX对并发性，性能和非阻塞算法的研究，如今构成了Exchange基础架构的核心部分。

+ Disruptor它是一个开源的并发框架，并获得2011 Duke’s 程序框架创新奖，能够在无锁的情况下实现网络的Queue并发操作。
+ Disruptor是一个高性能的异步处理框架，或者可以认为是最快的消息框架（轻量的JMS），也可以认为是一个观察者模式的实现，或者事件监听模式的实现。

https://blog.52itstyle.com/archives/2911/

## Grafana+Prometheus打造全方位立体监控系统

Prometheus是一个开源的服务监控系统，它通过HTTP协议从远程的机器收集数据并存储在本地的时序数据库上。

多维数据模型（时序列数据由metric名和一组key/value组成）
在多维度上灵活的查询语言(PromQl)
不依赖分布式存储，单主节点工作.
通过基于HTTP的pull方式采集时序数据
可以通过push gateway进行时序列数据推送(pushing)
可以通过服务发现或者静态配置去获取要采集的目标服务器
多种可视化图表及仪表盘支持

Prometheus通过安装在远程机器上的exporter来收集监控数据，后面我们将使用到node_exporter收集系统数据。

![](https://blog.52itstyle.com/usr/uploads/2017/11/4287056633.png)

https://blog.52itstyle.com/archives/1984/

## Docker

Docker最初目标是做一个特殊的LXC的开源系统，最后慢慢演变为它自己的一套容器运行时环境。

Docker提供了一个打包和运行应用的隔离环境，称之为容器，Docker的隔离和安全特性允许你在一个主机同时运行多个容器，而且它并不像虚拟机那样重量级，容器都是基于宿主机的内核运行的，它是轻量的，不管你运行的是ubuntu, debian还是其他Linux系统，用的内核都是宿主机内核

https://www.jianshu.com/p/7a1ce51a0eba?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io

## python爬虫模拟浏览器头

User-Agent 可以用 fake-useragent 这个项目来随机生成 UA 头

[fake-useragent github地址](https://github.com/EDDYCJY/fake-useragent)

## Golang市场行情

在招聘市场上，Golang 的招聘者更希望你是本科学历，大专和不限也有一定的份额，但市场份额相差较大

数据服务
电子商务
金融
企业服务
游戏

Golang 在这几个方面都有所应用，说明了在市场上，Golang 的路子是比较广阔的，前景不错


## 远程过程调用 RPC

RPC（Remote Procedure Call）即 远程过程调用，说的这么抽象，其实简化理解就是一个节点如何请求另一节点所提供的服务。

在文章 微服务调用链追踪中心搭建 一文中模拟出来的调用链：ServiceA ---> ServiceB ---> ServiceC 就是一个远程调用的例子，只不过这篇文章里是通过RestTemplate这种 同步调用方式，利用的是HTTP协议在应用层完成的，这种方法虽然奏效，但有时效率并不高。而RPC可以不依赖于应用层协议，可以直接基于TCP进行远程调用，在传输层中即可完成通信，因此更适于某些对效率要求更高的场景。由于RPC调用方式依赖于客户端与服务端之间建立Socket连接来实现二进制数据通信，底层会比较复杂，所以一些RPC框架应运而生来封装这种复杂性，让开发者将精力聚焦于业务之上。常见的RPC框架包括：Thrift、gRPC、Finagle、Dubbo等等

Thrift是Apache的项目，它结合了功能强大的软件堆栈和代码生成引擎，可以在诸多语言之间提供无缝支持。

https://www.jianshu.com/p/52fa63b222ac

## Redis
目前平台Redis具体使用到以下三个方面：

数据缓存，大并发下用于快读读取数据
消息队列，主要用于日志队列传输、异步任务
session存储，主要用于平台各个项目的用户信息存储，适用于负载均衡集群环境

目前平台使用Redis还是比较广了，下面与大家分享一款Redis监控实现，将会使用到以下组间grafana、prometheus以及redis_exporter。

https://blog.52itstyle.com/archives/2049/


## 微服务
微服务是一种应用程序架构风格，它让拥有单独功能的自包含程序通过网络和其它程序通信。典型地，这些微服务可以分开部署，因为它们通过一个定义良好的规格说明和有效的后向兼容性使得它们职责分明，从而可以避免突如其来的依赖破坏问题

然而，微服务更实在，因为它们通常基于 RESTful API，这对于实际的软件开发者而言，要比之前由各种企业软件公司发布的基于复杂的 XML 结构的架构容易得多！此外，成功的应用程序开始时都首先采用一种整体为先的方法，它使用一个单独的、共享的应用代码库和部署。只有在应用程序证明了它的有用性后，才会将它打破成微服务组件，从而让今后的开发和部署更轻松。这种方法叫做“整体为先”或者 “整体为先”模式。

http://fullstackpython.atjiang.com/microservices.html

## 微服务框架

微服务架构

你的整个应用程序将会被拆分成一个个功能独立的子系统，独立运行，系统与系统之间通过RPC接口通信。这样这些系统之间的耦合度大大降低，你的系统将非常容易扩展，团队协作效率提升了N个档次。这种架构通过眼下流行的SpringBoot和阿里巴巴吊炸天的Dubbo框架来实现。

容器化部署

你的各个微服务将采用目前处于浪潮之巅的Docker来实现容器化部署，避免一切因环境引起的各种问题，让你们团队的全部精力集中在业务开发上。

自动化构建

项目被微服务化后，各个服务之间的关系错中复杂，打包构建的工作量相当可怕。不过没关系，本文将借助Jenkins，帮助你一键自动化部署，从此你便告别了加班。

单机结构

我想大家最最最熟悉的就是单机结构，一个系统业务量很小的时候所有的代码都放在一个项目中就好了，然后这个项目部署在一台服务器上就好了。整个项目所有的服务都由这台服务器提供。这就是单机结构。
那么，单机结构有啥缺点呢？我想缺点是显而易见的，单机的处理能力毕竟是有限的，当你的业务增长到一定程度的时候，单机的硬件资源将无法满足你的业务需求。此时便出现了集群模式，往下接着看。

集群结构

集群模式在程序猿界由各种装逼解释，有的让你根本无法理解，其实就是一个很简单的玩意儿，且听我一一道来。

单机处理到达瓶颈的时候，你就把单机复制几份，这样就构成了一个“集群”。集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群。每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍（有几个节点就相当于提升了这么多倍）。

但问题是用户的请求究竟由哪个节点来处理呢？最好能够让此时此刻负载较小的节点来处理，这样使得每个节点的压力都比较平均。要实现这个功能，就需要在所有节点之前增加一个“调度者”的角色，用户的所有请求都先交给它，然后它根据当前所有节点的负载情况，决定将这个请求交给哪个节点处理。这个“调度者”有个牛逼了名字——负载均衡服务器。

集群结构的好处就是系统扩展非常容易。如果随着你们系统业务的发展，当前的系统又支撑不住了，那么给这个集群再增加节点就行了。但是，当你的业务发展到一定程度的时候，你会发现一个问题——无论怎么增加节点，貌似整个集群性能的提升效果并不明显了。这时候，你就需要使用微服务结构了

微服务结构

微服务就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在微服务结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。

举个例子，假设需要开发一个在线商城。按照微服务的思想，我们需要按照功能模块拆分成多个独立的服务，如：用户服务、产品服务、订单服务、后台管理服务、数据分析服务等等。这一个个服务都是一个个独立的项目，可以独立运行。如果服务之间有依赖关系，那么通过RPC方式调用。


https://mp.weixin.qq.com/s/8Oq6TBDKe1zWwtlvkWfWPQ

## GitZip for github

It can make the sub-directories and files of github repository as zip and download it.

不想Clone整个项目，只想下载单个文件或者单个文件夹时，用这个。

## User-Agent Switcher for Chrome

Chrome可以转换为别的浏览器进行访问，如IE、Safari、360甚至iOS、 Android等移动浏览器，方便用户进行测试


## DataGrip
数据库客户端：DataGrip
一个客户端全搞定主流数据库。不用再装Navicat、plsql了。

ps:DataGrip其实只是IDEA里一个集成功能，被单独抽离出来成了一个独立产品

## 微服务

微服务架构可以将你的系统拆分成多个负责不同任务的小的（单一上下文内）功能块responsibilities blocks，它们彼此互无感知，各自只提供用于通讯的通用指向common point。这个指向通常是已经将通讯协议和接口定义好的消息队列。

用 Python、 RabbitMQ 和 Nameko 实现微服务

在开发环境中使用 RabbitMQ 最简单的方式就是运行其官方的 docker 容器。

http://rabbitmq.mr-ping.com/ RabbitMQ 中文文档

文章是2016年的，目前redis作为消息队列热度更高一些

Nameko 一个让python程序员关注应用逻辑和测试的微服务框架。

Nameko github   https://github.com/nameko/nameko

https://linux.cn/article-7584-1.html

## 在Python中使用ZeroMQ和Docker构建微服务架构

微服务是一种架构风格，它包括多个彼此间进行通信的独立进程。在设计上，这些进程具有高度的可扩展性、相互解耦而且一次只完成一个较小的任务。这些服务都拥有自己的资源以及通过网络实现彼此间通信的进程。

相比于靠后端的单体结构来封装所有服务器逻辑的传统客户端－服务器架构（C/S架构）而言，微服务架构的差异性体现在关注点分离（Separation of concern）。这种设计模式更易于维护，使得灵活性、可扩展性及容错能力更强。但是这种分布式架构所的不足之处体现在如果设计不合理就会使得排错及维护变得复杂。

ZeroMQ来创建两个进程之间的通信。ZeroMQ提供了用于在套接字之上开发可扩展、分布式systed的构建块。它使用椭圆曲线密码体制（第四版）来实现安全性，并提供了即刻开启的通讯模式。

ZeroMQ有很多种通讯模式，为了开始我们的工作，让我们用ZeroMQ和Flask来配置一个简单的PUB－SUB。下图展示了组件之间的关系和数据流。

http://dockone.io/article/1068

## Redis面试刁难大全

可以说是redis高级内容

提及了很多实际中会遇到的问题，值得一看

https://mp.weixin.qq.com/s/507jyNbL4xCkxyW6Xk15Xg

